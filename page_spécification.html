<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
	<link rel="stylesheet" href="style.css" />
	<script src="script.js" defer></script>
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
    <title>Projet NSI: Site Web</title>
</head>
<body>
	
	<div class="barre">
		<input class="banniere" type="button" onclick=window.location.href='https://www.python.org/downloads/'; value="Python" />
		<input class="banniere" type="button" onclick=window.location.href='https://notepad-plus-plus.org/downloads/'; value="Notepad ++" />
		<input class="banniere" type="button" onclick=window.location.href='https://www.jetbrains.com/fr-fr/pycharm/'; value="PyCharm" />
		<input class="banniere" type="button" style="float:right" onclick=window.location.href='https://github.com/'; value="GitHub" /></br>
	</div>
	
	<h1>Spécification et mise au point</h1>
	
	<h2>Documenter ses programmes</h2>
	
	<h3>Exercice 87 </h3>	
	<p>
		Soit le programme suivant :</br>
	</p>	
	<p><em>
		def maximum_tableau(t):</br>
			&emsp;&emsp;m = 0</br>
			&emsp;&emsp;for i in range(len(t)):</br>
			&emsp;&emsp;&emsp;&emsp;if t[i] > t[m] :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;m = i</br>
			&emsp;&emsp;return m
	</p></em>
	<p><ol>
		<li>Que fait cette fonction ?
		<li>Que peut-on changer pour que cela soit plus clair ?
		<li>Appliquer cette fonction sur un tableau vide. Que constate-t-on ? </br> Afficher le maximum de ce tableau en utilisant la valeur retournée</ol>
	</p>
	<p>
		<div class = "correction"><a href="Exercices/Documentation et débugage/exercice87.py">Correction de l'exercice 87</a></br></div>
		<ol>
		<li>La fonction permet de trouver l'indice du nombre le plus grand dans le tableau t
		<li>On peut changer le nom de la variable m par indice_maximum et t par tab et changer le nom de la fonction par indice_maximum_tableau
		<li>On constate qu'il renvoie quand même l'indice 0 alors que le tableau n'a pas de contenu</ol>
	</p>
	
	<div class = "cours">
		<p>
			On peut, pour préciser un élément spécifique à une fonction, mettre un commentaire dans le code en le faisant précéder du symbole # pour qu’il ne soit pas pris en compte lors de l’interprétation du code par la machine.</br>
			Il est important de documenter correctement ses programmes, mais il faut s’abstenir de commenter à outrance, au-delà du nécessaire.</br>
			Le plus souvent, des noms de variables et de fonction bien choisis remplacent avantageusement les commentaires.</br>
			Il reste cependant des situations où les commentaires sont les bienvenus lorsqu’ils expliquent quelque chose qui ne se déduit pas immédiatement du code.</br>
			On peut aussi associer une documentation à la fonction sous la forme d’une chaine de caractères placée entre triple guillemets  <em>"""documentation"""</em> et placée au début de la fonction, juste sous l’en-tête.</br>
			On peut ensuite accéder à cette documentation avec la commande <em>help(nom_de_la_fonction)</em> dans l’interpréteur Python.</br>
		</p>
	</div>
	
		
	<h3>Exercice 88 </h3>	
	<p>
		Ajouter une documentation à la fonction de l’exercice précédent qui décrit ce qu’elle revoie et ses conditions d’utilisation. 
		Appeler ensuite cette documentation dans l’interpréteur Python.
	</p>	
	<p>
		<div class = "correction"><a href="Exercices/Documentation et débugage/exercice88.py">Correction de l'exercice 88</a></div>
	</p>


	<div class = "cours">
		<p>
			La première phrase, qui décrit ce que la fonction renvoie, s’appelle une postcondition.</br>
			La seconde phrase, qui décrit les conditions d’utilisation de la fonction s’appelle une précondition. </br>
		</p>
	</div>


	<h2>Programmation défensive</h2>
	
	<div class = "cours">
		La fonction <em>exit()</em> de Python interrompt le programme définitivement après avoir affiché le message passé en argument.</br>
		L’instruction <em>assert</em> combine le test d’une condition et l’interruption du programme, avec un message dans le cas où cette condition n’est pas vérifiée.
	</div>


	<h3>Exercice 89 </h3>
	<p>
		a) Reprendre l’exercice 87 en ajoutant en début de fonction, juste après la documentation, l’instruction :	
	</p>	
	<p><em>
		if len(t) == 0 :<br>
		&emsp;&emsp;exit("nom_de_la_fonction : message")</em>
	</p>
	<p>
		En adaptant la partie <em>nom_de_la_fonction : message.</em></br>
		Tester la fonction.
	</p>
	<p>
		b)	Une meilleure solution est d’utiliser l’instruction <em>assert</em>.
		Remplacer en début de fonction, juste après la documentation, le morceau de code précédent par :
	</p>
	<p>
		&emsp;&emsp;<em>assert len(t) > 0 , "message si la condition n’est pas vérifiée"</em>
	</p>
	<p>
        Tester la fonction.
	</p>
	<p><div class = "correction">
		<a href="Exercices/Documentation et débugage/exercice89A.py">Correction de l'exercice 89 partie A</a></br>
		<a href="Exercices/Documentation et débugage/exercice89B.py">Correction de l'exercice 89 partie B</a></div>
	</p>

	<div class = "cours">
		On appelle cela de la programmation défensive.</br>
		On peut aussi, plutôt que d’échouer, renvoyer une valeur qui ne peut pas être confondue avec un résultat valide, la valeur <em>None</em>.
	</div>


	<h3>Exercice 90 </h3>
	<p>
		Reprendre la fonction <em>maximum_tableau(t)</em> en utilisant cette solution.	</p>
	<p>
		<div class = "correction"><a href="Exercices/Documentation et débugage/exercice90.py">Correction de l'exercice 90</a></div>
	</p>



	<h2>Tester ses programmes</h2>
	
	<div class = "cours">
		<p>
			Pour vérifier si une fonction produit bien l’effet attendu, il faut l’utiliser sur quelques cas concrets.</br>
			Il est intéressant, pour éviter de réécrire ces tests plusieurs fois de les inclure dans le fichier où est définie la fonction. 
			On peut les effectuer en utilisant la construction <em>assert</em> suivie d’un test d’égalité.
		</p>
		<p>
			Il suffit de savoir ce que doit faire une fonction pour en écrire les tests associés.</br>
			On peut donc les écrire avant même d’avoir écrit la fonction elle-même.</br>
			Ils peuvent aussi être écrits par une autre personne pour avoir une vision différente des choses.</br>
			On ne peut en général pas écrire un ensemble de tests exhaustif qui suffirait à exclure toute erreur.</br>
			L’objectif est que l’ensemble des tests couvre « tous les comportements possibles d’un programme ».</br>
			Voici une liste de points d’usage général :
			<ul>
				<li>Si la spécification d’un programme mentionne plusieurs cas, chacun de ces cas doit avoir fait l’objet d’un test.</li>
				<li>Si une fonction renvoie une valeur booléenne, essayer d’avoir des tests conduisant à chacun des deux résultats possibles.</li>
				<li>Si le programme s’applique à un tableau, il faut inclure un test couvrant le cas du tableau vide.</li>
				<li>Si le programme s’applique à un nombre, il peut être utile de tester des valeurs positives, des valeurs négatives et 0.</li>
				<li>…</li>
		</p>
	</div>

	<h3>Exercice 91 </h3>
	<p>
		Créer un jeu de tests pour la fonction précédente.</br>
		Exemple : <em>assert maximum_tableau([3,5,9,4,7,9,13,15,10])== 7</em>
	</p>
	<p>
		<div class = "correction"><a href="Exercices/Documentation et débugage/exercice91.py">Correction de l'exercice 91</a></div>
	</p>	
	
	<h2>Corriger les erreurs</h2>
	
	<div class = "cours">
		L’échec d’un test atteste qu’une erreur est présente dans un programme, mais n’indique pas directement du type d’erreur, ni de l’endroit du programme où elle se trouve.</br>
		Nous allons ici étudier des outils pour localiser et identifier l’erreur afin de la corriger.
	</div>
	
		
	<h3>Exercice 92 </h3>
	<p>
		Soit la fonction suivante qui teste si un tableau est bien rangé dans l’ordre croissant :
	</p>	
	<p><em>
		def est_croissant (t) :</br>
			&emsp;&emsp;i = len(t) - 1</br>
			&emsp;&emsp;while i >= 0 :</br>
			&emsp;&emsp;&emsp;&emsp;if t[i] <= t[i+1] :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return True</br>
			&emsp;&emsp;&emsp;&emsp;else :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return False</br>
			&emsp;&emsp;&emsp;&emsp;i -= 1
	</p></em>
	<p><ol>
		<li>Créer un jeu de tests pour cette fonction avec un tableau rangé dans l’ordre croissant [1, 2, 3, 4], un autre qui ne l’est pas [1, 3, 2, 4] et un tableau vide.</br> Que constate-t-on ?
		<li>Faire tourner la fonction à la main.</br> On se rend alors compte dès le premier tour de boucle, l’indice i+1 n’existe pas.</br> On décide alors de modifier la fonction de la façon suivante au début de la boucle un affichage de la valeur de i :
	</p>
	<p><em>
		def est_croissant (t) :</br>
			&emsp;&emsp;i = len(t) - 1</br>
			&emsp;&emsp;while i >= 0 :</br>
			&emsp;&emsp;&emsp;&emsp;print ("nouveau tour avec i = " , i)</br>
			&emsp;&emsp;&emsp;&emsp;if t[i-1] &lt; t[i] :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return True</br>
			&emsp;&emsp;&emsp;&emsp;else :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return False</br>
			&emsp;&emsp;i -= 1
	</p></em>
	<p>
		Appliquer le jeu de tests précédent à cette nouvelle fonction.</br>Que constate-t-on ?
	</p>
		<li>On décide donc de modifier à nouveau la fonction :
	<p><em>
		def est_croissant (t) :</br>
			&emsp;&emsp;i = len(t) - 1</br>
			&emsp;&emsp;while i >= 0 :</br>
			&emsp;&emsp;&emsp;&emsp;print ("nouveau tour avec i = " , i)</br>
			&emsp;&emsp;&emsp;&emsp;if t[i-1] > t[i] :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return True</br>
			&emsp;&emsp;&emsp;&emsp;else :</br>
			&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return False</br>
			&emsp;&emsp;i -= 1
	</p></em>	
	<p>
		Appliquer le jeu de tests précédent à cette nouvelle fonction.</br>Que constate-t-on ?
	</p>
		<li>Modifier à nouveau la fonction pour la corriger et le tester.
	<p>
		On peut aussi écrire un programme effectuant une série de tests.</ol>
	</p>		
	<p>Correction :
		<ol>
		<li>On constate une erreur dans les tests
		<li>On constate toujours une erreur pour le second test
		<li>On constate une erreur pour le premier test
		<li><div class = "correction"><a href="Exercices/Documentation et débugage/exercice92.py">Correction de l'exercice 92 question 4</a> :</ol></div>
	</p>





	<h3>Exercice 93 </h3>
	<p>
		<ol>
		<li>Ecrire une fonction <em>tableau_croissant(n)</em> qui crée un tableau d’éléments aléatoires dont la taille <em>n</em> est donnée en paramètre et dans lequel les éléments sont triés dans l’ordre croissant.
	</p>
	<p>
		<li>Vérifier qu’il fonctionne bien en utilisant la boucle suivante :</br>
		<em>
		for n in range(2, 20) : </br>
			&emsp;&emsp;for i in range(10) :</br>
			&emsp;&emsp;&emsp;&emsp;t = tableau-croissant(n)</br>
			&emsp;&emsp;&emsp;&emsp;assert est_croissant(t)</br>
		</em>	
	</p></ol>
	<div class = "correction">
		<a href="Exercices/Documentation et débugage/exercice93.py">Correction de l'exercice 93</a> 
	</div>
	
	
	<div class="li">
		<input class="favorite style" type="button" onclick=window.location.href='page_tableaux_listes_avancés.html'; value="Page précédente" />
		<input class="favorite style" type="button" onclick=window.location.href='index.html'; value="Sommaire" />
		<input class="favorite style" type="button" onclick=window.location.href='page_ensembles.html'; value="Page suivante" />
	</div>
	
		
	<div id="scrollUp">
		<a href="#top"><img src="bouton_haut.png" style="width:100px"/></a>
	</div>

</body>
</html>